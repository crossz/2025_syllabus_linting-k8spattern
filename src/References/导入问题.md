# 《Kubernetes Patterns》第二版各章节中提到的核心问题（Problem）及其背景和影响

### 📖 章节问题概述

|模式名称|核心问题|影响与困难|
|---|---|---|
|**Predictable Demands**|不同编程语言和业务逻辑的应用对资源（如CPU、内存）和运行时依赖（如存储、配置）的需求差异很大。Kubernetes 需要明确知晓这些需求才能为应用找到合适的运行节点。|若未明确定义资源需求和依赖，可能导致应用部署失败、资源分配不足或浪费，甚至影响集群中其他应用的稳定性。|
|**Declarative Deployment**|如何以声明式方式（而非命令式）表达应用部署策略，确保部署过程可靠、可重复，并能应对复杂的发布需求（如滚动更新、蓝绿发布等）。|命令式部署容易出错且难以维护；缺乏可靠的部署策略会导致版本发布风险高、回滚困难，影响应用可用性。|
|**Health Probe**|仅检查容器进程状态不足以判断应用健康度。应用可能进程仍在运行但已无法服务（如内存溢出、死循环、死锁或资源抖动）。|Kubernetes 需要更可靠的方式来检测应用是否真正“健康”和就绪，否则流量可能被错误路由到不可用的实例，导致服务中断或用户体验下降。|
|**Managed Lifecycle**|容器需要一种方式来自平台（Kubernetes）事件（如启动、终止），并做出适当响应，以优雅地处理任务（如完成当前请求、释放资源）。|若应用无法响应生命周期事件（如 SIGTERM），可能导致强制终止（SIGKILL），造成请求中断、数据不一致或资源泄漏。|
|**Automated Placement**|在包含大量微服务的系统中，手动将容器调度到合适节点不可管理。容器间存在依赖、对节点有要求，且资源需求和集群资源都在不断变化。|不当的调度会影响分布式系统的可用性、性能和资源利用率。可能导致资源碎片化、节点利用率低下，或应用因无法调度而停滞。|
|**Batch Job**|需要运行一次性任务或批量处理工作（如数据处理、报告生成），这些任务完成后便应退出，无需持续运行。|传统的做法可能缺乏重试、日志管理和状态跟踪机制。任务失败后难以追踪和恢复，且需要有效的机制来获取任务结果。|
|**Periodic Job**|需要运行周期性任务（如系统维护、文件清理、发送邮件），但使用专用的调度软件或  cron  可能成本高或存在单点故障。|将调度逻辑嵌入应用内部（如使用 Quartz）会带来高可用性挑战（需要主从选举），增加了应用的复杂性和资源消耗。|
|**Daemon Service**|需要在每个节点上运行提供平台能力（如监控、日志采集、存储）的守护进程。|确保每个节点上都运行且只运行一个指定的守护进程实例，并管理其生命周期（如节点加入或离开集群时），否则可能影响集群功能或导致资源冲突。|
|**Singleton Service**|某些应用（如主从架构中的主节点、分布式锁管理器）在任何时候都只能有一个活跃实例在运行。|在分布式环境中协调单一实例颇具挑战。若多个实例同时激活（“脑裂”），可能导致数据损坏、系统行为不一致或服务中断。|
|**Stateless Service**|如何设计和操作真正无状态的应用服务，使其能够充分利用 Kubernetes 的弹性伸缩、故障恢复和轻松管理的能力。|应用若隐藏状态或未能外部化状态，将难以水平扩展，实例无法互换，故障恢复也会变得复杂，违背云原生应用的设计原则。|
|**Stateful Service**|有状态应用（如数据库、缓存）的每个实例都是唯一的，具有持久化存储、稳定网络标识和启动顺序等需求。|Kubernetes 默认将应用视为无状态、可互换的。有状态应用需要特殊的编排来管理其身份、存储、网络和顺序，否则难以在 Kubernetes 上稳定运行。|
|**Service Discovery**|应用需要发现并与其他服务（集群内或集群外）通信。服务端点可能是动态的（Pod IP 会变），并且通信可能需要考虑服务是否就绪。|硬编码 IP 地址不可行。缺乏有效的服务发现机制会导致应用无法定位依赖服务，造成连接失败、超时或访问到未就绪的实例，影响系统整体功能。|
|**Self Awareness**|即使是通常无状态的应用，有时也需要在运行时了解自身及其环境的信息（如 Pod 名称、IP、资源限制、标签等），这些信息在部署时可能无法完全确定。|应用若无法感知其运行时的上下文环境，就难以做出适应性的决策（如根据分配的资源调整线程池大小），或无法实现高级的运维逻辑（如基于标签的特定行为）。|

