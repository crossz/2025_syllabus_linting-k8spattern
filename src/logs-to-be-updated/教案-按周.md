# 《Kubernetes设计模式》深度解析与实战课程教案（按周）

## 第1周：云原生架构演进（理论2学时）

### 1. 教学目的与要求
- 能够定义云原生应用的特征，理解从单体架构到微服务的转变
- 掌握云原生的核心理念和价值（弹性、可观测性、韧性）
- 理解Kubernetes在云原生中的地位
- 为后续深入学习建立理论基础

### 2. 教学重点难点
**重点：**
- 云原生架构的演进路径和核心价值
- 从传统架构到云原生架构的思维转变

**难点：**
- 理解微服务架构的优缺点及适用场景
- 云原生概念的深度理解

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我有一个庞大的单体应用，每次更新都像一场灾难，牵一发而动全身，而且难以针对性地扩展某个功能。我该如何改造我的软件架构，使其在云时代更具弹性、更易维护？"
- 引导学生思考传统架构的局限性

#### (2) 新课讲授：架构的演进（75分钟）
- 引入**微服务架构**作为解决单体应用困境的思路，将复杂系统分解为一组小而专注的服务
- 讲解**云原生之路 (The Path to Cloud Native)**，阐述这不仅是技术的变革，更是思想、文化和流程的全面升级
- 分析单体架构→SOA→微服务→云原生的完整演进路径
- 深入讲解云原生的三大核心价值：弹性、可观测性、韧性
- 介绍Kubernetes作为云原生核心平台的地位和作用

#### (3) 课堂互动与讨论（15分钟）
- 讨论：哪些场景适合微服务架构？哪些不适合？
- 分享：知名互联网公司的架构演进案例

### 4. 思考题及作业题
1. 思考题：传统单体架构与微服务架构各有哪些优缺点？在什么场景下应该选择微服务架构？
2. 思考题：为什么说云原生不仅是技术变革，更是思维方式的转变？
3. 作业题：调研一个知名互联网公司的微服务架构转型案例，分析其转型过程中遇到的挑战和解决方案

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解云原生的核心理念和三大价值
- 认识到微服务架构在云原生中的重要性
- 了解云原生架构的演进路径
- 建立云原生思维的基础

---

## 第2周：容器化基础（理论2学时）

### 1. 教学目的与要求
- 理解容器化的核心概念和价值
- 掌握容器与虚拟机的区别
- 了解Docker的基本概念和原理
- 理解容器镜像的分层机制

### 2. 教学重点难点
**重点：**
- 容器的概念与作用
- 容器vs虚拟机的比较
- 容器镜像的分层原理

**难点：**
- 理解容器的隔离机制
- 容器镜像优化的思路

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我的微服务（Java, Python, Go...）在我的开发机上能跑，但到了测试或生产环境就因为依赖、库版本不同而失败。如何才能实现'一次构建，到处运行'？"

#### (2) 新课讲授：容器化技术（75分钟）
- 引入**容器(Container)**作为现代应用的标准交付单元
- 详细对比容器与虚拟机的区别：启动速度、资源占用、隔离级别等
- 讲解容器是不可变的，一旦构建，其内部环境便固定下来
- 深入分析容器镜像的分层原理和优化策略
- 介绍Docker的基本概念：镜像、容器、仓库、Dockerfile

#### (3) 知识拓展：容器化最佳实践（15分钟）
- Dockerfile编写原则
- 多阶段构建优化
- 镜像安全扫描

### 4. 思考题及作业题
1. 思考题：容器与虚拟机有什么区别？各有什么优缺点？
2. 思考题：如何优化Docker镜像大小？为什么镜像大小对生产环境很重要？
3. 作业题：研究Dockerfile的最佳实践，总结5条最重要的原则

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解容器化的核心价值和基本原理
- 掌握容器与虚拟机的区别
- 了解容器镜像的分层机制
- 建立容器化思维

---

## 第3周：云原生基础实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握Docker环境的安装和基本操作
- 能够编写Dockerfile并构建镜像
- 学会使用minikube/kind搭建本地Kubernetes环境
- 将理论应用于实践

### 2. 教学重点难点
**重点：**
- Docker基本命令的使用
- 编写docker-compose 脚本进行单机容器编排
- Kubernetes（轻量版）单机环境的搭建

**难点：**
- 环境配置的排错
- 镜像构建的优化

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 检查实验环境准备情况
- 分组安排和任务说明

#### (2) 动手实践（75分钟）
- **Docker环境配置**
  - 安装Docker Desktop或Docker Engine
  - 验证Docker安装：运行hello-world容器
  - 学习基本命令：docker run, docker ps, docker images

- **容器化实践**
  - 参考教材搭建一个基于 nginx 的 web 服务器
  - 练习 docker ps、docker rm、docker、docker images 等基础功能
  - 练习 docker cp、docker run -p -v 等配置与互动操作
  - 尝试将 docker run 命令 改成 docker-compose 的脚本
  - 通过 docker compose 运行容器并验证功能，陈述这种编排模式的优点和意义

- **Kubernetes环境搭建（下节上机预习）**
  - 安装minikube或kind或k3s
  - 启动本地Kubernetes集群(单机版）
    (验证集群状态：kubectl get nodes)
  - 通过kubernetes部署和启动nginx服务

#### (3) 实验总结（15分钟）
- 各组展示实验结果
- 常见问题解答
- 实验报告要求说明

### 4. 思考题及作业题
- 步骤1 git 平台撰写 markdown：注册华为云和gitcode，在 git code 上提交
- 步骤2 docker 环境安装，下载 nginx:1.29 的镜像，通过 `docker images` 验证
- 步骤3 部署 nginx 服务，并通过大模型生成一个自己设计的 html 页面，研究如何通过这个 nginx 部署自己的 html 页面
- 步骤4 将 `docker run` 命令转换为 `docker-compose.yaml` 脚本，并通过 `docker compose` 的方式启动 nginx web 项目

### 5. 课堂小结
通过本次实验，学生应该能够：
- 掌握Docker的基本操作
- 学会编写和优化Dockerfile
- 成功搭建本地Kubernetes环境
- 具备基本的容器化实践能力

---

## 第4周：资源管理基础（理论2学时）

### 1. 教学目的与要求
- 理解Kubernetes中的资源管理机制
- 掌握可压缩资源与不可压缩资源的区别
- 了解cgroup原理及其在资源限制中的作用
- 理解资源请求与限制的概念

### 2. 教学重点难点
**重点：**
- 可压缩资源(CPU)与不可压缩资源(Memory)的区别
- 资源请求(Requests)与限制(Limits)的概念
- cgroup原理简介

**难点：**
- 理解资源超限的处理机制
- 合理评估应用资源需求

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："如果我直接在服务器上运行一个容器，不加任何资源限制，最坏会发生什么情况？这与在Kubernetes中运行有何不同？"

#### (2) 新课讲授：资源管理基础（75分钟）
- 区分**可压缩资源(CPU)**和**不可压缩资源(Memory)**
- 讲解当内存耗尽时，应用进程会被操作系统无情地**杀死(OOMKilled)**
- 讲解当CPU繁忙时，应用只会被**节流(throttled)**，性能下降但不会崩溃
- 介绍cgroup原理：控制组如何限制和监控资源使用
- 讲解Kubernetes中的资源请求与限制机制

#### (3) 案例分析（15分钟）
- 分析生产环境中的资源超限案例
- 讨论资源规划的最佳实践

### 4. 思考题及作业题
1. 思考题：为什么CPU被视为"可压缩"资源而内存被视为"不可压缩"资源？这种区别对应用设计有什么影响？
2. 思考题：在生产环境中，如何确定一个应用的合理资源请求和限制值？
3. 作业题：设计一个实验，分别测试CPU限制和内存限制对应用性能的影响

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解Kubernetes中的资源管理机制
- 掌握可压缩与不可压缩资源的区别
- 了解cgroup的基本原理
- 建立资源规划的基础概念

---

## 第5周：资源管理实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握Pod资源请求与限制的配置方法
- 能够模拟和观察资源超限场景
- 学会使用ResourceQuota和LimitRange进行命名空间级资源管理
- 理解多租户环境下的资源隔离

### 2. 教学重点难点
**重点：**
- 配置Pod的资源请求与限制
- ResourceQuota和LimitRange的使用
- 观察资源超限现象

**难点：**
- 理解资源限制的实际效果
- 多租户资源隔离的设计

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 回顾上周理论知识
- 实验环境检查
- 实验任务说明

#### (2) 动手实践（90分钟）
- **基础资源限制实验**
  - 创建Pod并配置CPU和内存限制
  - 模拟内存溢出场景，观察OOMKilled现象
  - 模拟CPU密集任务，观察节流效果
  - 使用kubectl describe查看事件日志

- **命名空间资源管理**
  - 创建ResourceQuota设置命名空间资源配额
  - 配置LimitRange设置默认资源限制
  - 创建多个Pod验证资源限制效果
  - 测试资源配额超限的情况

- **多租户实践**
  - 为不同团队创建独立命名空间
  - 配置不同的资源配额策略
  - 验证资源隔离效果

#### (3) 实验总结（15分钟）
- 实验结果验证
- 问题答疑
- 实验报告要求

### 4. 思考题及作业题
1. 作业题：完成实验报告，记录资源限制的配置和观察结果
2. 作业题：为一个多团队共享的Kubernetes集群设计资源管理策略
3. 思考题：资源限制对应用性能有什么影响？如何平衡资源利用和稳定性？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 掌握Pod资源限制的配置方法
- 理解资源超限的处理机制
- 学会使用命名空间级资源管理工具
- 具备基本的资源规划能力

---

## 第6周：声明式部署基础（理论2学时）

### 1. 教学目的与要求
- 理解声明式API的核心理念和优势
- 掌握Deployment资源的配置和管理
- 了解ReplicaSet与Pod的关系
- 理解滚动更新的内部机制

### 2. 教学重点难点
**重点：**
- 声明式API vs 命令式API
- Deployment资源的配置和管理
- 滚动更新机制

**难点：**
- 理解声明式API的控制器模式
- 滚动更新的参数调整

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我如何确保我的应用始终运行指定数量的副本？当Pod崩溃时如何自动恢复？当需要更新版本时如何实现零停机？"

#### (2) 新课讲授：声明式部署（75分钟）
- 讲解**声明式API**的核心理念：描述期望状态，系统自动达成
- 对比声明式与命令式的区别和优势
- 深入分析Deployment资源的结构和配置
- 讲解ReplicaSet如何管理Pod生命周期
- 详细分析滚动更新的内部机制：maxSurge、maxUnavailable参数的作用

#### (3) 实战演示（15分钟）
- 现场演示Deployment的创建和更新
- 展示回滚操作的过程

### 4. 思考题及作业题
1. 思考题：声明式API相比命令式API有什么优势？
2. 思考题：滚动更新过程中，如何确保服务的连续性？
3. 作业题：设计一个实验，比较RollingUpdate和Recreate两种更新策略的区别

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解声明式API的核心理念
- 掌握Deployment的基本配置
- 了解滚动更新的工作机制
- 建立自动化部署的基础概念

---

## 第7周：声明式部署实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握Deployment资源的创建和管理
- 能够配置和触发滚动更新
- 学会执行回滚操作
- 实现蓝绿部署和金丝雀发布

### 2. 教学重点难点
**重点：**
- 创建和管理Deployment
- 配置滚动更新参数
- 执行回滚操作

**难点：**
- 监控更新进度
- 蓝绿部署和金丝雀发布的实现

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 回顾声明式部署理论知识
- 准备实验用的容器镜像
- 分组安排

#### (2) 动手实践（90分钟）
- **基础部署实验**
  - 创建简单的Deployment
  - 配置副本数管理
  - 模拟Pod故障，观察自动恢复
  - 使用kubectl rollout status监控部署状态

- **滚动更新实验**
  - 准备不同版本的应用镜像
  - 触发滚动更新，调整maxSurge和maxUnavailable参数
  - 监控更新过程中的服务可用性
  - 验证更新完成后的状态

- **高级部署策略**
  - 实现蓝绿部署：创建两套完整环境
  - 配置金丝雀发布：逐步切换流量比例
  - 使用Helm简化复杂应用的部署
  - 练习回滚操作：kubectl rollout undo

#### (3) 实验总结（15分钟）
- 各组展示部署结果
- 对比不同部署策略的优缺点
- 实验报告要求

### 4. 思考题及作业题
1. 作业题：完成实验报告，包括部署过程截图和问题记录
2. 作业题：设计一个金丝雀发布方案，包括流量分配策略和监控指标
3. 思考题：在生产环境中，如何选择合适的部署策略？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 熟练掌握Deployment的管理
- 实现各种部署策略
- 具备零停机更新的能力
- 理解不同部署场景的适用策略

---

## 第8周：健康探针与生命周期管理（理论2学时）

### 1. 教学目的与要求
- 理解健康探针的概念和作用
- 掌握不同类型探针的配置和使用方法
- 了解容器生命周期事件和钩子机制
- 理解优雅停机的实现方式

### 2. 教学重点难点
**重点：**
- 存活探针、就绪探针、启动探针的区别
- 探针参数配置与在部署中的作用
- 容器生命周期基础与钩子机制

**难点：**
- 探针设计的最佳实践
- 优雅停机的完整实现

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我还是对存活探针和就绪探针感到困惑。它们都检查应用的健康，到底该在什么场景下分别使用它们？"

#### (2) 新课讲授：健康探针与生命周期（75分钟）
- 讲解**就绪探针**：回答"你现在能营业吗？"，用于应用启动、依赖加载、临时过载等场景
- 讲解**存活探针**：回答"你还活着吗？"，用于检测死锁等无法自行恢复的致命错误
- 介绍**启动探针**：解决启动时间过长的应用的探针配置难题
- 深入分析探针的配置参数：initialDelaySeconds、periodSeconds、timeoutSeconds等
- 讲解容器生命周期事件和钩子机制：postStart、preStop
- 分析优雅停机的完整流程和实现方法

#### (3) 案例分析（15分钟）
- 分析复杂应用的探针设计案例
- 演示优雅停机的配置和效果

### 4. 思考题及作业题
1. 思考题：在什么情况下应该使用启动探针而非就绪探针？
2. 思考题：如何设计一个包含数据库连接的应用的健康检查策略？
3. 作业题：设计一个实验，测试不同探针配置对应用启动的影响

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解不同类型探针的使用场景
- 掌握探针的配置方法
- 了解容器生命周期管理机制
- 实现优雅停机策略

---

## 第9周：健康探针与生命周期管理实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握存活探针和就绪探针的配置方法
- 能够测试探针失败场景
- 学会配置postStart和preStop钩子
- 理解PodDisruptionBudget的作用

### 2. 教学重点难点
**重点：**
- 配置各种健康探针
- 测试探针失败场景
- 配置生命周期钩子

**难点：**
- 调试探针配置问题
- 优雅停机的完整测试

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 回顾健康探针理论知识
- 准备测试用的应用
- 实验任务分配

#### (2) 动手实践（90分钟）
- **健康探针配置实验**
  - 为Web应用配置HTTP就绪探针
  - 配置exec类型的存活探针
  - 测试探针失败时的Pod行为
  - 观察Pod的重启和流量摘除

- **生命周期钩子实验**
  - 配置postStart钩子执行初始化脚本
  - 配置preStop钩子实现优雅停机
  - 测试SIGTERM信号处理
  - 验证优雅停机的时间窗口

- **高可用保障实验**
  - 创建PodDisruptionBudget
  - 测试集群维护时的Pod保护
  - 验证最小可用副本数的保障

#### (3) 实验总结（15分钟）
- 实验结果验证
- 问题讨论
- 最佳实践总结

### 4. 思考题及作业题
1. 作业题：完成实验报告，包括探针配置和测试结果
2. 作业题：设计一个生产级的健康检查方案
3. 思考题：如何平衡探针的敏感性和稳定性？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 熟练配置各种健康探针
- 实现优雅的应用生命周期管理
- 保障应用的高可用性
- 具备生产级健康检查设计能力

---

## 第10周：高级调度（理论2学时）

### 1. 教学目的与要求
- 理解Kubernetes调度器的工作原理
- 掌握节点亲和性、Pod亲和性的配置方法
- 了解污点与容忍度的作用和使用场景
- 理解公有云上的容器集群服务

### 2. 教学重点难点
**重点：**
- 调度器工作原理（过滤和打分）
- 节点亲和性与Pod亲和性
- 污点与容忍度

**难点：**
- 复杂调度策略的组合使用
- 调度性能优化

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我的K8s集群里有各种各样的节点：有的CPU强，有的内存大，有的带GPU。我如何能'告诉'K8s我的Pod的偏好，让它被调度到最合适的节点上？"

#### (2) 新课讲授：高级调度策略（75分钟）
- 讲解**调度器工作原理**：过滤(Filtering)和打分(Scoring)机制
- 深入分析**节点亲和性(Node Affinity)**：必须满足vs偏好满足
- 讲解**Pod亲和性与反亲和性**：Pod间的关系调度
- 介绍**污点与容忍度(Taints and Tolerations)**：实现专用节点
- 讨论**公有云Kubernetes服务**的特点和优势

#### (3) 实战演示（15分钟）
- 演示复杂的调度策略配置
- 展示调度结果的验证方法

### 4. 思考题及作业题
1. 思考题：节点亲和性和Pod亲和性有什么区别？
2. 思考题：如何使用污点和容忍度实现专用节点？
3. 作业题：设计一个高可用的多可用区部署方案

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解调度器的工作机制
- 掌握各种调度策略
- 设计复杂的调度方案
- 了解云原生部署的最佳实践

---

## 第11周：高级调度实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握节点亲和性和Pod亲和性的配置
- 学会设置污点与容忍度
- 能够实现复杂调度策略
- 验证调度结果的正确性

### 2. 教学重点难点
**重点：**
- 调度策略的配置方法
- 调度结果的验证
- 复杂场景的实现

**难点：**
- 调试调度问题
- 性能优化

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 回顾调度理论知识
- 准备多节点集群环境
- 实验任务说明

#### (2) 动手实践（90分钟）
- **基础调度实验**
  - 为节点添加标签
  - 配置节点亲和性调度
  - 验证Pod调度结果
  - 使用kubectl describe查看调度事件

- **高级调度实验**
  - 配置Pod反亲和性实现高可用
  - 设置节点污点
  - 配置容忍度实现专用节点
  - 组合多种调度约束

- **验证与调试**
  - 使用kubectl get pods -o wide查看分布
  - 分析调度失败的原因
  - 优化调度策略

#### (3) 实验总结（15分钟）
- 实验结果展示
- 问题讨论
- 最佳实践分享

### 4. 思考题及作业题
1. 作业题：完成实验报告，包括调度配置和验证结果
2. 作业题：设计一个生产环境的调度策略
3. 思考题：如何在大规模集群中优化调度性能？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 熟练配置各种调度策略
- 解决复杂的调度需求
- 验证和调试调度结果
- 具备生产级调度设计能力

---

## 第12周：行为模式（理论2学时）

### 1. 教学目的与要求
- 理解Kubernetes中的不同Pod管理模式
- 掌握Job、CronJob、DaemonSet、StatefulSet的配置和使用
- 了解无状态服务和有状态服务的区别
- 能够为不同类型的应用选择合适的控制器

### 2. 教学重点难点
**重点：**
- 不同控制器的特性和适用场景
- 无状态vs有状态服务的区别
- 控制器选择依据

**难点：**
- 有状态服务的管理复杂性
- 复杂应用场景的控制器选择

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："我的应用场景中，除了需要7x24小时运行的在线服务，还有一次性任务、定时任务、守护服务、有状态服务，如何用K8s来管理这些不同类型的工作负载？"

#### (2) 新课讲授：行为模式（75分钟）
- 讲解**任务型作业**：Job（一次性任务）、CronJob（定时任务）
- 讲解**守护服务**：DaemonSet（每个节点一个）
- 深入分析**无状态vs有状态服务**：Deployment vs StatefulSet
- 讨论不同控制器的**选择依据**：应用场景、数据需求、网络要求等
- 介绍**服务发现机制**：内部和外部访问方式

#### (3) 控制器对比分析（15分钟）
- 对比各种控制器的特性
- 分析选择策略

### 4. 思考题及作业题
1. 思考题：Job和CronJob有什么本质区别？
2. 思考题：为什么说有状态服务比无状态服务更难管理？
3. 作业题：为一个电商系统设计完整的工作负载架构

### 5. 课堂小结
通过本次课程，学生应该能够：
- 理解不同Pod管理模式
- 掌握各种控制器的使用
- 为应用选择合适的控制器
- 设计复杂的工作负载架构

---

## 第13周：行为模式实验（理论讲解 1 学时，实验 1 学时）

### 1. 教学目的与要求
- 掌握Job、CronJob、DaemonSet、StatefulSet的配置
- 能够部署MySQL主从集群
- 理解服务发现与访问机制
- 实现完整的工作负载架构

### 2. 教学重点难点
**重点：**
- 各种控制器的配置和使用
- 有状态服务的部署
- 服务发现的实现

**难点：**
- StatefulSet的存储和网络配置
- 复杂架构的协调

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 回顾行为模式理论知识
- 准备实验用的容器镜像
- 分组任务分配

#### (2) 动手实践（90分钟）
- **任务型作业实验**
  - 创建简单Job处理一次性任务
  - 配置CronJob实现定时备份
  - 验证任务执行结果和日志

- **守护服务实验**
  - 部署DaemonSet实现日志收集
  - 验证每个节点的Pod分布
  - 测试DaemonSet的更新策略

- **有状态服务实验**
  - 创建StatefulSet部署MySQL主从
  - 配置Headless Service和持久存储
  - 验证数据持久性和故障恢复
  - 测试读写分离功能

- **服务发现实验**
  - 配置内部服务访问
  - 创建Ingress实现外部访问
  - 验证服务发现机制

#### (3) 实验总结（15分钟）
- 各组展示部署成果
- 架构设计讨论
- 问题解答

### 4. 思考题及作业题
1. 作业题：完成完整的实验报告
2. 作业题：设计一个生产级的工作负载架构
3. 思考题：如何确保有状态服务的高可用性？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 熟练使用各种工作负载控制器
- 部署复杂的有状态应用
- 实现完整的服务架构
- 具备生产级部署能力

---

## 第14周：有状态服务管理（理论2学时）

### 1. 教学目的与要求
- 深入理解无状态服务和有状态服务的本质区别
- 掌握StatefulSet的高级特性和使用方法
- 了解有状态服务的存储和网络管理策略
- 理解PV/PVC的生命周期管理

### 2. 教学重点难点
**重点：**
- 无状态vs有状态服务的深度对比
- StatefulSet的存储和网络特性
- PV/PVC生命周期管理

**难点：**
- 有状态应用的部署和管理策略
- 数据一致性和高可用设计

### 3. 教学过程
#### (1) 导入环节：提出核心问题（15分钟）
- 提问："在K8s中，最核心的一对概念就是无状态应用和有状态应用。我什么时候应该用Deployment，什么时候又必须用StatefulSet？它们在存储和网络方面到底有什么根本区别？"

#### (2) 新课讲授：有状态服务深度解析（75分钟）
- **深度对比**：无状态服务 vs 有状态服务的完整对比
- **StatefulSet特性**：稳定身份、稳定存储、稳定网络
- **存储管理**：PV/PVC机制、StorageClass、动态供给
- **网络特性**：Headless Service、稳定的DNS记录
- **高可用设计**：主从架构、数据备份、故障恢复

#### (3) 架构设计案例（15分钟）
- 分析MySQL主从集群的完整设计
- 讨论数据一致性保障策略

### 4. 思考题及作业题
1. 思考题：为什么说有状态服务比无状态服务更难管理？具体难在哪里？
2. 思考题：如何设计有状态服务的数据备份和恢复策略？
3. 作业题：设计一个Redis集群的StatefulSet部署方案

### 5. 课堂小结
通过本次课程，学生应该能够：
- 深度理解有状态服务的特性
- 掌握StatefulSet的高级用法
- 设计有状态服务的完整架构
- 具备数据服务的管理能力

---

## 第15周：华为云CCE综合实践（实验2学时）

### 1. 教学目的与要求
- 掌握在华为云CCE服务中部署Kubernetes集群
- 能够将本地部署方案迁移到公有云环境
- 理解公有云Kubernetes服务的特点和优势
- 完成团队项目的云端部署

### 2. 教学重点难点
**重点：**
- 华为云CCE集群的创建和配置
- 本地方案向公有云的迁移
- 团队项目部署

**难点：**
- 云资源配置的优化
- 跨环境兼容性问题解决

### 3. 教学过程
#### (1) 实验准备（15分钟）
- 华为云账号准备
- 团队项目方案review
- 部署任务分配

#### (2) 动手实践（90分钟）
- **华为云CCE环境准备**
  - 创建CCE集群（选择合适的规格）
  - 配置集群网络和存储
  - 设置镜像仓库（SWR）
  - 配置访问权限和安全组

- **项目迁移部署**
  - 调整配置文件适配云环境
  - 上传镜像到SWR
  - 部署应用到CCE集群
  - 配置负载均衡和域名访问
  - 验证服务功能和性能

- **监控和优化**
  - 配置监控告警
  - 优化资源配置
  - 成本分析和优化建议

#### (3) 实验总结（15分钟）
- 各组项目演示
- 经验分享
- 问题讨论

### 4. 思考题及作业题
1. 作业题：完成云端部署的完整文档
2. 作业题：对比本地和云端部署的差异
3. 思考题：公有云部署的优势和局限性是什么？

### 5. 课堂小结
通过本次实验，学生应该能够：
- 熟练使用华为云CCE服务
- 完成项目的云端部署
- 理解云原生在公有云环境的应用
- 具备生产环境的部署能力

---

## 第16周：课程总结与综合复习（理论2学时）

### 1. 教学目的与要求
- 系统回顾课程所学的核心知识点
- 理解云原生项目开发的完整流程
- 了解云原生技术的发展趋势
- 制定个人后续学习计划

### 2. 教学重点难点
**重点：**
- 课程核心知识系统回顾
- 云原生项目完整开发流程
- 技术发展趋势和职业规划

**难点：**
- 知识体系的融会贯通
- 实际应用中的问题解决

### 3. 教学过程
#### (1) 项目成果展示（30分钟）
- 各组展示云端部署成果
- 优秀实践案例分享
- 问题分析和改进建议

#### (2) 知识体系回顾（60分钟）
- **云原生基础**：架构演进、容器化、Kubernetes核心概念
- **资源管理**：资源限制、命名空间隔离、容量规划
- **应用部署**：声明式API、Deployment、滚动更新、部署策略
- **健康保障**：健康探针、生命周期管理、优雅停机
- **高级调度**：调度器原理、亲和性、污点容忍
- **工作负载**：Job、CronJob、DaemonSet、StatefulSet
- **服务管理**：服务发现、Ingress、负载均衡

#### (3) 未来发展展望（15分钟）
- 云原生技术发展趋势
- 相关认证和职业路径
- 持续学习资源推荐
- 社区参与建议

### 4. 思考题及作业题
1. 作业题：个人课程学习总结报告
2. 作业题：制定未来6个月的云原生学习计划
3. 思考题：云原生技术对传统IT架构带来了哪些变革？

### 5. 课堂小结
通过本次总结课程，学生应该能够：
- 系统掌握云原生技术体系
- 理解完整的项目开发流程
- 明确个人发展方向
- 具备持续学习的能力

---

## 课程总体回顾

本课程通过16周的理论学习和实践训练，学生应该能够：

### 核心能力
1. **云原生思维**：建立云原生架构思维，理解微服务和容器化价值
2. **容器技术**：掌握Docker容器化技术，能够独立容器化应用
3. **Kubernetes运维**：熟练使用Kubernetes进行应用部署和管理
4. **架构设计**：能够设计高可用、可扩展的云原生应用架构
5. **故障排查**：具备解决生产环境问题的能力

### 实践成果
1. 完成从单体应用到云原生架构的完整迁移
2. 在华为云CCE上成功部署生产级应用
3. 建立完整的CI/CD流水线
4. 实现应用的监控和可观测性

### 职业发展
1. 具备云原生架构师的基础能力
2. 能够胜任Kubernetes运维工程师岗位
3. 为后续的云原生技术深入学习和认证打下基础

**课程寄语**：
云原生技术正在重塑整个IT行业，掌握Kubernetes设计模式不仅是技术能力的提升，更是面向未来的职业投资。希望同学们能够将所学知识应用到实际工作中，在云原生的道路上持续精进！
